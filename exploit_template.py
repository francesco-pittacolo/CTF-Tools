import requests
import time
from check_flag import *
from info_from_flagID import *
from play_sound import *

team_ip = "10.60.64.1" #da modificare in base al team
submitter_ip = "http://10.81.64.9:5000/submit" #scrivere qua ip del submitter
teams = 81 #da modificare in base al numero di team
service_port = "" #porta del servizio, da usare nell'exploit per la connessione al servizio
service_name = "" #nome servizio per flagID
service_attribute_1 = "" # primo argomento flagID
service_attribute_2 = "" # secondo argomento flagID
service_attribute_3 = None #eventuale terzo argomento flagID, lasciare None altrimenti
regex_flag = "[A-Z0-9]{31}=$"
#scrivere l'exploit qua per attaccare servizio per un singolo ip, ritorna una specifica flag come testo.
# arg1, arg2 e arg3 sono i valori recuperati da flagID, nomi modificabili 
#ricordarsi di connettersi al servizio tramite ip e porta
def exploit(ip, arg1, arg2, arg3):
    flag = ""

    return flag

#per mandare attacco, modificare solo se si vuole fare attacco a tutti i round trovati o solo ad uno specifico
def send_attack(ip, team_id):
    print(f"Attacco in corso a {ip}\n")
    #position = 3 #posizione per ottenere round specifico, qui ultimo round (da 0 a (len(round recuperati da flagID)-1)), opzionale
    try:
        results = get_info(team_id, service_name, service_attribute_1, service_attribute_2, service_attribute_3) #ritorna da flagID una lista di dizionari, un dizionario per round
    except Exception as e:
        play_fail_sound()
    #per ottenere informazioni di un round specifico decommentare questa funzione e commentare quella precedente
    #results = get_info_specific_round(team_id, service, service_attribute_1, service_attribute_2, service_attribute_3, position) 
    print(results) # debug opzionale

    for i in range(0, len(results)):
        if not results[i]: # check se è vuoto
            continue

        arg1 = results[i][service_attribute_1]
        arg2 = results[i][service_attribute_2]
        if service_attribute_3:
            arg3 = results[i][service_attribute_3]
        else:
            arg3 = None
        flag = exploit(ip, arg1, arg2, arg3)
        if check_flag(flag):
        #save = save_flag(flag) #per eventuale salvataggio in locale della flag
            data = {'flag': flag}
            response = requests.post(submitter_ip, data=data)
            print("Status Code:", response.status_code)
            print("Response Body:", response.text)
        else:
            play_fail_sound()
    return

#funzione per salvare le flag su un file, ma non serve più
def save_flag(flag):
    try:
        with open("CTF-Tools/flags.txt", "a") as f:
            f.write(flag + "\n")
        print(f"Flag salvata: {flag}\n")
        return 1
    except Exception as e:
        print(f"[!] Errore durante il salvataggio della flag: {e}\n")
        play_error_sound()
        return 0

if __name__ == "__main__":
    try:
        teams_round = dict()
        while True:
            flags_found = 0
            for i in range(teams):
                ip = f"10.60.{i}.1"
                if ip == team_ip:
                    continue
                try:
                    print(f"Inizio attacco a {ip}")
                    flag = send_attack(ip, i)
                    if flag:  # Se è stata trovata una flag
                        flags_found += 1
                except Exception as e:
                    print(f"[!] Errore durante l'attacco a {ip}: {e}")
                    play_error_sound()

            print(f"Giro completato. Trovate {flags_found} flag. Aspetto 120 secondi per il prossimo attacco...\n")
            time.sleep(120) #da modificare a seconda delle necessità
    except Exception as e:
        print(f"[!] ERRORE CRITICO: il programma si è arrestato inaspettatamente: {e}")
        play_error_sound()