import requests
import time
from check_flag import *
from info_from_flagID import *
#from play_sound import *
from Exploit_Template.Windows.save_flag import *
from Exploit_Template.sender import *

team_ip = "10.60.63.1" #da modificare in base al team
submitter_ip = "http://10.81.63.27:5000/api/submit" #scrivere qua ip del submitter
author = "f" #per autore dell'exploit
teams = 80 #da modificare in base al numero di team
service_port = "" #porta del servizio, da usare nell'exploit per la connessione al servizio
service_name = "" #nome servizio per flagID
service_attribute_1 = "" # primo argomento flagID
service_attribute_2 = "" # secondo argomento flagID
service_attribute_3 = None #eventuale terzo argomento flagID, lasciare None altrimenti
regex_flag = "[A-Z0-9]{31}=$"
teams_rounds = {team_id: set() for team_id in range(1, teams+1)} #team da 1 a teams (escludo il nop)

#scrivere l'exploit qua per attaccare servizio per un singolo ip, ritorna una specifica flag come testo.
# arg1, arg2 e arg3 sono i valori recuperati da flagID, nomi modificabili
# arg3 se non è presente è impostato di default a None
#ricordarsi di connettersi al servizio tramite ip e porta
def exploit(ip, arg1, arg2, arg3):
    flag = "" #qui verrà salvata la flag
    #script qua


    return flag

#per mandare attacco, modificare solo se si vuole fare attacco a tutti i round trovati o solo ad uno specifico
def send_attack(ip, team_id):
    print(f"Attacco in corso a {ip}\n")
    flags_found = 0
    fail_count = 0
    success_count = 0
    #position = 3 #posizione per ottenere round specifico, qui ultimo round (da 0 a (len(round recuperati da flagID)-1)), opzionale
    try:
        results = get_info(team_id, service_name, service_attribute_1, service_attribute_2, service_attribute_3) #ritorna da flagID una lista di dizionari, un dizionario per round
    except Exception as e:
        print(f"[!] Errore nella raccolta delle informazioni di {ip}: {e}")  
        #play_fail_sound()

    #per ottenere informazioni di un round specifico decommentare questa funzione e commentare quella precedente
    #results = get_info_specific_round(team_id, service, service_attribute_1, service_attribute_2, service_attribute_3, position)
     
    print(results) # debug opzionale

    for i in range(0, len(results)):

        if not results[i]:  # Verifica che il risultato non sia vuoto
            print(f"[!] Risultato vuoto per il round {i}, ignorato.")
            continue

        arg1 = results[i][service_attribute_1]
        arg2 = results[i][service_attribute_2]
        current_round = results[i]["round"]

        if service_attribute_3:
            arg3 = results[i][service_attribute_3]
        else:
            arg3 = None

        if current_round not in teams_rounds[team_id]:
            flag = exploit(ip, arg1, arg2, arg3)
            if check_flag(flag):
                flags_found += 1
                #save = save_flag(flag) #per eventuale salvataggio in locale della flag
                teams_rounds[team_id].add(current_round)
                remove_rounds(team_id) #per rimuovere round troppo vecchi
                #data = {'flag': flag}
                try:
                    #response = requests.post(submitter_ip, data=data)
                    response = send_single_flag(flag, author, service_name, submitter_ip)
                    #print(f"Status Code: {response.status_code}")
                    #print(f"Response Body: {response.text}")
                    #if response.status_code != 200:
                    if not response:
                        fail_count += 1
                        print(f"[!] Flag non accettata! :( )")
                        #play_error_sound()
                    else:
                        success_count += 1
                except Exception as e:
                    print(f"[!] Errore durante l'invio della flag: {e}")
                    #play_error_sound()
            #else:
                #play_fail_sound()
    return flags_found, success_count, fail_count

#Per rimuovere round troppo vecchi dal dizionario teams_rounds
def remove_rounds(team_id):
    rounds = teams_rounds[team_id]
    if len(rounds) > 5 or (max(rounds) - min(rounds) > 5):
        rounds.remove(min(rounds))


if __name__ == "__main__":
    try:
        while True:
            total_flags_found = 0
            total_success_count = 0
            total_fail_count = 0
            for i in range(1, teams+1): #escludo il nop
                ip = f"10.60.{i}.1"
                if ip == team_ip:
                    continue
                try:
                    print(f"Inizio attacco a {ip}")
                    flags_found, success_count, fail_count = send_attack(ip, i)
                    total_flags_found += flags_found
                    total_success_count += success_count
                    total_fail_count += fail_count
                except Exception as e:
                    print(f"[!] Errore durante l'attacco a {ip}: {e}")
                    #play_error_sound()     

            print(f"Giro completato. Trovate {total_flags_found} flag. Aspetto 120 secondi per il prossimo attacco...\n")
            print(f"\n--- Riepilogo ---")
            print(f"Flag inviate con successo: {total_success_count}")
            print(f"Flag fallite: {total_fail_count}")

            time.sleep(120) #da modificare a seconda delle necessità
            
    except KeyboardInterrupt:
        print("\n[!] Interruzione manuale rilevata (Ctrl+C)")
        #play_error_sound()
    except Exception as e:
        print(f"[!] ERRORE CRITICO: il programma si è arrestato inaspettatamente: {e}")
        #play_error_sound()
