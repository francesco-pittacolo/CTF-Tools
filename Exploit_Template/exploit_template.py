import requests
import time
from check_flag import *
from info_from_flagID import *
from play_sound import *
from save_flag import *

team_ip = "10.60.64.1" #da modificare in base al team
submitter_ip = "http://10.81.64.9:5000/submit" #scrivere qua ip del submitter
teams = 80 #da modificare in base al numero di team
service_port = "" #porta del servizio, da usare nell'exploit per la connessione al servizio
service_name = "" #nome servizio per flagID
service_attribute_1 = "" # primo argomento flagID
service_attribute_2 = "" # secondo argomento flagID
service_attribute_3 = None #eventuale terzo argomento flagID, lasciare None altrimenti
regex_flag = "[A-Z0-9]{31}=$"
teams_rounds = {team_id: set() for team_id in range(1, teams+1)}
#scrivere l'exploit qua per attaccare servizio per un singolo ip, ritorna una specifica flag come testo.
# arg1, arg2 e arg3 sono i valori recuperati da flagID, nomi modificabili 
#ricordarsi di connettersi al servizio tramite ip e porta
def exploit(ip, arg1, arg2, arg3):
    flag = "" #qui verrà salvata la flag
    #script qua


    return flag

#per mandare attacco, modificare solo se si vuole fare attacco a tutti i round trovati o solo ad uno specifico
def send_attack(ip, team_id):
    print(f"Attacco in corso a {ip}\n")
    flags_found = 0
    #position = 3 #posizione per ottenere round specifico, qui ultimo round (da 0 a (len(round recuperati da flagID)-1)), opzionale
    try:
        results = get_info(team_id, service_name, service_attribute_1, service_attribute_2, service_attribute_3) #ritorna da flagID una lista di dizionari, un dizionario per round
    except Exception as e:
        print(f"[!] Errore nella raccolta delle informazioni di {ip}: {e}")  
        play_fail_sound()

    #per ottenere informazioni di un round specifico decommentare questa funzione e commentare quella precedente
    #results = get_info_specific_round(team_id, service, service_attribute_1, service_attribute_2, service_attribute_3, position)
     
    print(results) # debug opzionale

    for i in range(0, len(results)):

        if not results[i]:  # Verifica che il risultato non sia vuoto
            print(f"[!] Risultato vuoto per il round {i}, ignorato.")
            continue

        arg1 = results[i][service_attribute_1]
        arg2 = results[i][service_attribute_2]
        current_round = results[i]["round"]

        if service_attribute_3:
            arg3 = results[i][service_attribute_3]
        else:
            arg3 = None

        if current_round not in teams_rounds[team_id]:
            flag = exploit(ip, arg1, arg2, arg3)
            if check_flag(flag):
                flags_found += 1
                #save = save_flag(flag) #per eventuale salvataggio in locale della flag
                teams_rounds[team_id].add(current_round)
                remove_rounds(team_id) #per rimuovere round troppo vecchi
                data = {'flag': flag}
                try:
                    response = requests.post(submitter_ip, data=data)
                    print(f"Status Code: {response.status_code}")
                    print(f"Response Body: {response.text}")
                    if response.status_code != 200:
                        print(f"[!] Errore nell'invio della flag al server: {response.status_code}")
                        play_error_sound()
                except Exception as e:
                    print(f"[!] Errore durante l'invio della flag: {e}")
                    play_error_sound()
            else:
                play_fail_sound()
    return flags_found

#Per rimuovere round troppo vecchi dal dizionario teams_rounds
def remove_rounds(team_id):
    rounds = teams_rounds[team_id]
    if len(rounds) > 5 or (max(rounds) - min(rounds) > 5):
        rounds.remove(min(rounds))


if __name__ == "__main__":
    try:
        while True:
            total_flags_found = 0
            for i in range(1, teams+1):
                ip = f"10.60.{i}.1"
                if ip == team_ip:
                    continue
                try:
                    print(f"Inizio attacco a {ip}")
                    flags_found = send_attack(ip, i)
                    total_flags_found += flags_found
                except Exception as e:
                    print(f"[!] Errore durante l'attacco a {ip}: {e}")
                    play_error_sound()     

            print(f"Giro completato. Trovate {total_flags_found} flag. Aspetto 120 secondi per il prossimo attacco...\n")
            time.sleep(120) #da modificare a seconda delle necessità
            
    except KeyboardInterrupt:
        print("\n[!] Interruzione manuale rilevata (Ctrl+C)")
        play_error_sound()
    except Exception as e:
        print(f"[!] ERRORE CRITICO: il programma si è arrestato inaspettatamente: {e}")
        play_error_sound()